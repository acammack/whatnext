#!/bin/bash

# Edit these to change where your tasks live
WN_CONFIG_DIRECTORY=~/.whatnext
WN_PROJECTS_DIRECTORY=$WN_CONFIG_DIRECTORY/projects
WN_ACTIVE_DIRECTORY=$WN_CONFIG_DIRECTORY/active-tasks
WN_CURRENT=$WN_CONFIG_DIRECTORY/current

WN_EDITOR=${EDITOR:-nano}

_whatnext_dispatch() {
  local cmd project task path next postponed active_project
  local project_dir task_f active_dir active_l

  # Name the parameters
  cmd="${1:-echo}"
  project="$2"
  task="$3"

  project_dir=$WN_PROJECTS_DIRECTORY/$project
  task_f=$project_dir/$task

  active_dir=$WN_ACTIVE_DIRECTORY/$project
  active_l=$active_dir/$task

  case "$cmd" in
    add)
      mkdir -p $project_dir
      touch $task_f
      ;;
    queue)
      mkdir -p $active_dir
      ln -s $task_f $active_l
      ;;
    start)
      mkdir -p $active_dir
      ln -s $task_f $active_l
      ln -nsf $active_l $WN_CURRENT
      ;;
    finish)
      path=$(realpath $WN_CURRENT)
      active_project=$(dirname $(readlink $WN_CURRENT ))
      # Hide the underlying issue
      [ -f "$path" ] &&
        mv $path $(dirname $path)/.$(basename $path)
      # Remove it from the active list
      rm $(readlink $WN_CURRENT)
      rm $WN_CURRENT
      # Remove the project from active if no tasks are left
      rmdir --ignore-fail-on-non-empty $active_project

      ls $WN_ACTIVE_DIRECTORY/*

      ;;
    list)
        ls $WN_ACTIVE_DIRECTORY/*
      ;;
    open)
      [ -f $(realpath $WN_CURRENT) ] &&
        $WN_EDITOR $WN_CURRENT
      ;;
    echo | *)
      path=$(realpath $WN_CURRENT)
      [ -f "$path" ] &&
        echo $path &&
        cat $path
  esac
}

if [ $(basename $0) = "whatnext" ]; then
  # Ensure directories
  mkdir -p $WN_ACTIVE_DIRECTORY
  mkdir -p $WN_PROJECTS_DIRECTORY
  
  _whatnext_dispatch "$@"
fi
